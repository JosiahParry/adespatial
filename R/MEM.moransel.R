#' Function to select the minimum subset of spatial eigenvectors that best minimizes the 
#' spatial autocorrelation (Moran's I) of a vector of interest
#' 
#' \code{MEM.moransel} computes the spatial eigenvectors (also referred to as MEM variables) of 
#' the spatial weighting matrix (SWM) provided (\code{listw}). Then it tests whether the 
#' vector of interest (\code{y}) displays a significant spatial autocorrelation, using the 
#' Moran's I (permutation test). If the Moran's I is significant, \code{MEM.moransel}
#' selects the smallest subset of spatial eigenvectors necessary best capturing the spatial
#' autocorrelation of \code{y}.
#' 
#' @details Standard statistical tests (e.g., ordinary least squares, generalized linear models)
#' requires the model residuals to be independent. The presence of spatial autocorrelation in
#' the residuals violates this condition, hence inflating the type I error rate (false discovery
#' rate) of the analysis. An efficient way to solve this issue is to add a small number of
#' spatial predictors as covariables in the model (Diniz-Filho and Bini 2005). These spatial 
#' predictors, or MEM variables are generated by diagonalization of a doubly centered 
#' spatial weighting matrix (SWM), which generates n - 1 predictors. The eigenvalue of the
#' latter are proportional to their Moran's I, so that, the MEM variables associated to positive
#' eigenvalues, for example, display positively autocorrelated patterns (details in Dray et al.
#' 2006). One usually generates only the MEM variables associated to the sign of spatial
#' autocorrelation one is interested in (\code{MEM.autocor}, either set to \code{"positive"},
#' \code{"negative"}, or \code{"all"}). 
#' The choice of the SWM is a crucial step when
#' generating spatial predictors on the basis of irregular sampling designs. This issue has
#' been adressed in Bauman et al. (2018a) (see function \code{\link{listw.candidates}} and
#' \code{\link{listw.select}} to build a set of candidate SWMs and to optimize the choice
#' of the best SWM, respectively).
#' A second crucial step, if the MEM variables are to be used in a model including actual
#' explanatory variables (e.g., environmental) is the selection of a subset of spatial 
#' eigenvectors, once the selection of a SWM was made. The selection of a subset of spatial
#' predictors avoids model overfitting and a loss of statistical power to detect the 
#' contribution of the environment to the variability of the response data (Griffith 2003, 
#' Dray et al. 2006, Blanchet et al. 2008, Peres-Neto and Legendre 2010, 
#' Diniz-Filho et al. 2012). Bauman et al. (2018b) have shown that while the forward selection
#' with double stopping criterion (Blanchet et al. 2008) was the eigenvector selection method
#' that yielded the highest statistical power and R-squared estimation accuracy, performing
#' the eigenvector selection on the basis of the minimum number of predictors best minimizing 
#' the spatial autocorrelation of the vector of interest yielded results nearly as good as the
#' forward selection and had the advantage to select a smaller subset of predictors. The
#' selection method to choose therefore depends on the objective of the study: describing as 
#' accurately as possible the patterns of \code{y} (forward selection), or account for its 
#' spatial autocorrelation with the smallest number of spatial predictors (Griffith and 
#' Peres-Neto 2006, see MIR selection in Bauman et al. 2018b). 
#' The latter objective is generally the one to go for when one whiches to account for the 
#' spatial autocorrelation of the residuals of a model of a response variable against a set of 
#' actual predictors, because the greatest the number of covariables added to the models, 
#' the greatest the standard errors of the coefficients. Selecting the smallest subset of 
#' spatial predictors accounting for the model residuals spatial autocorrelation is the best
#' way of keeping the (actual predictor) coefficient estimates as accurate as possible
#' (Griffith and Peres-Neto 2006, Diniz-Filho et al. 2012).
#' 
#' To select this subset of spatial predictors, \code{MEM.moransel} computes the Moran's I of
#' \code{y} (e.g. residuals of the model of the response variable against environmental 
#' variables) and tests it by permutation. If the Moran's I is significant, the function 
#' searches among the set of generated spatial predictors the one that best minimizes the value
#' of the Moran's I. A model of \code{y} against the selected eigenvector is built, and the
#' significance of the Moran's I of the model residuals is tested again. The procedure goes on
#' until the Moran's I of the model residuals is not significant anymore, hence the name of
#' Minimization of moran's I in the Residuals (MIR).
#' 
#' Note that, while \code{MEM.moransel} selects the best subset of spatial predictors for one 
#' given SWM using the MIR selection, the selection of a best SWM can be done on the 
#' basis of the MIR criterion with the function \code{\link{listw.select}}.
#' 
#' @param y Vector on the basis of which the spatial autocorrelation will be tested and the
#' spatial predictors selected; \code{y} can be the residuals of a model of the response
#' variable against a set of actual (e.g. environmental) predictors
#' @param listw A spatial weighting matrix of class \code{listw}; can be created with functions
#' of the package \code{spdep}, or with the user-friendly function \code{listw.candidates}
#' @param MEM.autocor Sign of the spatial eigenvectors to generate; "positive", "negative", 
#' or "all", for positively, negatively autocorrelated eigenvectors, or both, respectively; 
#' default is "positive"
#' @param nperm Number of permutations when testing the Moran's I; Default is 999
#' @param alpha Significance threshold value for the test of the Moran's I; Default is 0.05
#' 
#' @return The function returns a list of two elements:
#' \describe{
#' \item{MEM.all}{An object of class \code{orthobasisSp}, subclass \code{orthobasis},
#' containing all the complete set of generated MEM varriables stored as a \code{data.frame}.
#' Generated by \code{\link{scores.listw}}.}
#' \item{MEM.select}{Dataframe of the selected subset of MEM variables.}
#' }
#' 
#' @author Bauman David \email{dbauman@@ulb.ac.be}, \email{davbauman@@gmail.com}
#' 
#' @seealso \code{\link{listw.candidates}}, \code{\link{listw.select}}, 
#' \code{link{scores.listw}}
#' 
#' @references Bauman D., Fortin M-J, Drouet T. and Dray S. (2018a) Optimizing the choice of 
#' a spatial weighting matrix in eigenvector-based methods. Ecology
#' 
#' Bauman D., Drouet T., Dray S. and Vleminckx J. (2018b) Disentangling good from bad 
#' practices in the selection of spatial or phylogenetic eigenvectors. Ecography, 41, 1--12
#' 
#' Blanchet G., Legendre P. and Borcard D. (2008) Forward selection of explanatory variables.
#' Ecology, 89(9), 2623--2632
#' 
#' Diniz-Filho J.A.F., Bini L.M. (2005) Modelling geographical patterns in 
#' species richness using eigenvector-based spatial filters. Global Ecology and Biogeography,
#' 14, 177--185
#' 
#' Diniz-Filho J.A.F., Bini L.M., Rangel T.F., Morales-Castilla I. et al. (2012) On the 
#' selection of phylogenetic eigenvectors for ecological analyses. Ecography, 35, 239--249
#' 
#' Dray S., Legendre P. and Peres-Neto P. R. (2006) Spatial modeling: a comprehensive 
#' framework for principal coordinate analysis of neighbor matrices (PCNM). Ecological 
#' Modelling, 196, 483--493
#' 
#' Griffith D. (2003) Spatial autocorrelation and spatial filtering: gaining understanding 
#' through theory and scientific visualization. Springer, Berlin
#' 
#' Griffith D., Peres-Neto P. (2006) Spatial modeling in Ecology: the flexibility of 
#' eigenfunction spatial analyses. Ecology, 87, 2603--2613
#' 
#' Peres-Neto P. and Legendre P. (2010) Estimating and controlling for spatial structure 
#' in the study of ecological communities. Global Ecology and Biogeography, 19, 174--184
#' 
#' @keywords spatial
#' 
#' @examples
#'  if(require(vegan)) { 
#'# Illustration of the MIR selection on the oribatid mite data
#'# (Borcard et al. 1992, 1994 for details on the dataset):
#'# *******************************************************
#'# Community data (response matrix):
#'data(mite)
#'# We will compute the example on a single species:
#'spe <- mite[, 2]
#'# Environmental explanatory dataset:
#'data(mite.env)
#'# We only use two numerical explanatory variables:
#'env <- mite.env[, 1:2]
#'dim(env)
#'# Coordinates of the 70 sites:
#'data(mite.xy)
#'coord <- mite.xy
#'# We build the model we are interested in:
#'mod <- lm(spe ~ ., data = env)
#'# In order to avoid possible type I error rate inflation issues, we check 
#'# whether the model residuals are independent, and if they are spatially
#'# autocorrelated, we select a small subset of MEM variables to add to the
#'# model as covariables with the MIR selection:
#'# 1) We build a spatial weighting matrix based on Gabriel graph with a
#'# weighting function decreasing linearly with the distance:
#'w <- listw.candidates(coord, nb = "gab", weights = "flin")
#'# 2) We test the spatial autocorrelation of the model residuals and, if
#'# necessary, select a subset of spatial predictors:
#'y <- residuals(mod)
#'MEM <- MEM.moransel(y = y, listw = w[[1]], MEM.autocor = "positive", nperm = 999,
#'                    alpha = 0.05)
#'dim(MEM$MEM.select)
#'# The residuals of the model presented spatial autocorrelation. The selection
#'# of one MEM variable was sufficient for the Moran's I of the residuals not to
#'# be significant anymore.
#'# 3) We can reconstruct our model adding the selected MEM variable as covariables:
#'env2 <- cbind(env, MEM$MEM.select)
#'mod_complete <- lm(spe ~ ., data = env2)
#'summary(mod_complete)$coefficient[, 1]   # Coefficient estimates
#'summary(mod_complete)$coefficient[, 2]   # Standard errors
#'}
#'
#' @importFrom spdep moran moran.mc
#' @importFrom stats lm residuals
#' @export MEM.moransel

"MEM.moransel" <- function (y, 
                            listw, 
                            MEM.autocor = c("positive", "negative", "all"), 
                            nperm = 999, 
                            alpha = 0.05) {
  
  if (is.vector(y) == FALSE) stop("y must be a vector")
  
  SPATIAL = "FALSE"
  # number of regions:
  nb_sites <- length(y)
  
  MEM.autocor <- match.arg(MEM.autocor)
  MEM <- scores.listw(listw, MEM.autocor = MEM.autocor)
  
  I.test <- function (y, listw, nperm, MEM.autocor, alpha) {
    # The function I.test() tests the significance of the Moran's I of 'y' by 'nperm'
    # permutations. If 'MEM.autocor' = 'all', two p-values are computed to test
    # whether the observed Moran's I is greater or smaller than expected by chance, 
    # respectively. The p-values are then corrected by the Sidak correction for multiple
    # tests to control the type I error rate.
    # The function returns "TRUE" if at least one (corrected) p-value is <= 'alpha', and
    # "FALSE" otherwise.
    if (MEM.autocor == "all")
      alter <- c("greater", "less")
    else {
      if (MEM.autocor == "positive") 
        alter <- "greater"
      else alter <- "less"
    }
    p <- sapply(alter, function (x) moran.mc(y, listw, nperm, alternative = x)$p.value)
    # Correction of both p-values with the Sidak correction if 'MEM.autocor' = 'all':
    if (MEM.autocor == "all") p <- 1-(1-p)^2
    if (length(which(p <= alpha)) == 0)
      signif <- FALSE
    else signif <- TRUE
    return(signif)
  }
  
  I <- I.test(y, listw, nperm, MEM.autocor, alpha)
  if (I == TRUE) {
    SPATIAL <- "TRUE"
    MEM.sel <- data.frame(row.names = row.names(MEM))
  }
  
  nbloop <- c()
  while (I == TRUE) {
    nbloop <- c(nbloop, 1)                   # Loop counter
    I.vector <- vector("numeric", ncol(MEM)) # For the I computed with each MEM variable
    for (i in 1:ncol(MEM)) {
      mod <- lm(y ~ MEM[, i])
      I.vector[i] <- moran(residuals(mod), listw, nb_sites, Szero(listw))$I
    }
    min.moran <- which.min(abs(I.vector))
    # Selection of the MEM variable(s) best minimizing the Moran's I value of the residuals:
    MEM.sel[, sum(nbloop)] <- MEM[, min.moran]
    colnames(MEM.sel)[sum(nbloop)] <- colnames(MEM)[min.moran]
    y <- residuals(lm(y ~ MEM.sel[, sum(nbloop)]))
    I <- I.test(y, listw, nperm, MEM.autocor, alpha)
  }
  
  if (SPATIAL == "FALSE") return("No significant spatial structure")
  else list(MEM.all = MEM, MEM.select = MEM.sel)
}
